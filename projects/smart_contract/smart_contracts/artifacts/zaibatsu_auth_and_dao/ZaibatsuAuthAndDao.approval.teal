#pragma version 10

smart_contracts.zaibatsu_auth_and_dao.contract.ZaibatsuAuthAndDao.approval_program:
    txn ApplicationID
    bnz main_entrypoint@2
    callsub __init__

main_entrypoint@2:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:14
    // class ZaibatsuAuthAndDao(ZaibatsuBase):
    method "hello(string)string"
    method "create()bool"
    method "update()bool"
    method "delete()bool"
    method "set_service_contract_address(address)bool"
    method "authorize_pool_creation(axfer,application,string,string,string,string,uint64,uint64)(string,uint64,uint64)"
    method "optin_pool_asset(axfer,string)void"
    method "fund_pool(string,uint64,account,application,axfer,asset,uint64)(uint64,bool)"
    method "approve_pool_vote(string,axfer)(uint64,string)"
    method "opt_contract_into_asset(asset)bool"
    txna ApplicationArgs 0
    match main_hello_route@3 main_create_route@4 main_update_route@5 main_delete_route@6 main_set_service_contract_address_route@7 main_authorize_pool_creation_route@8 main_optin_pool_asset_route@9 main_fund_pool_route@10 main_approve_pool_vote_route@11 main_opt_contract_into_asset_route@12
    err // reject transaction

main_hello_route@3:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:15
    // @a4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:14
    // class ZaibatsuAuthAndDao(ZaibatsuBase):
    txna ApplicationArgs 1
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:15
    // @a4.abimethod()
    callsub hello
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_create_route@4:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:19
    // @a4.abimethod(create="allow")
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    callsub create
    byte 0x00
    int 0
    uncover 2
    setbit
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_update_route@5:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:24
    // @a4.abimethod(allow_actions=["UpdateApplication"])
    txn OnCompletion
    int UpdateApplication
    ==
    assert // OnCompletion is UpdateApplication
    txn ApplicationID
    assert // is not creating
    callsub update
    byte 0x00
    int 0
    uncover 2
    setbit
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_delete_route@6:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:33
    // @a4.abimethod(allow_actions=["DeleteApplication"])
    txn OnCompletion
    int DeleteApplication
    ==
    assert // OnCompletion is DeleteApplication
    txn ApplicationID
    assert // is not creating
    callsub delete
    byte 0x00
    int 0
    uncover 2
    setbit
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_set_service_contract_address_route@7:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:39
    // @a4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:14
    // class ZaibatsuAuthAndDao(ZaibatsuBase):
    txna ApplicationArgs 1
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:39
    // @a4.abimethod()
    callsub set_service_contract_address
    byte 0x00
    int 0
    uncover 2
    setbit
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_authorize_pool_creation_route@8:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:45
    // @a4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:14
    // class ZaibatsuAuthAndDao(ZaibatsuBase):
    txn GroupIndex
    int 1
    -
    dup
    gtxns TypeEnum
    int axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    btoi
    txnas Applications
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    extract 2 0
    txna ApplicationArgs 4
    extract 2 0
    txna ApplicationArgs 5
    extract 2 0
    txna ApplicationArgs 6
    btoi
    txna ApplicationArgs 7
    btoi
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:45
    // @a4.abimethod()
    callsub authorize_pool_creation
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_optin_pool_asset_route@9:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:97
    // @a4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:14
    // class ZaibatsuAuthAndDao(ZaibatsuBase):
    txn GroupIndex
    int 1
    -
    dup
    gtxns TypeEnum
    int axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:97
    // @a4.abimethod()
    callsub optin_pool_asset
    int 1
    return

main_fund_pool_route@10:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:111
    // @a4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:14
    // class ZaibatsuAuthAndDao(ZaibatsuBase):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    txnas Accounts
    txna ApplicationArgs 4
    btoi
    txnas Applications
    txn GroupIndex
    int 1
    -
    dup
    gtxns TypeEnum
    int axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 5
    btoi
    txnas Assets
    txna ApplicationArgs 6
    btoi
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:111
    // @a4.abimethod()
    callsub fund_pool
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_approve_pool_vote_route@11:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:169
    // @a4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:14
    // class ZaibatsuAuthAndDao(ZaibatsuBase):
    txna ApplicationArgs 1
    extract 2 0
    txn GroupIndex
    int 1
    -
    dup
    gtxns TypeEnum
    int axfer
    ==
    assert // transaction type is axfer
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:169
    // @a4.abimethod()
    callsub approve_pool_vote
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_opt_contract_into_asset_route@12:
    // smart_contracts/zaibatsu_base/contract.py:36
    // @a4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:14
    // class ZaibatsuAuthAndDao(ZaibatsuBase):
    txna ApplicationArgs 1
    btoi
    txnas Assets
    // smart_contracts/zaibatsu_base/contract.py:36
    // @a4.abimethod()
    callsub opt_contract_into_asset
    byte 0x00
    int 0
    uncover 2
    setbit
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return


// smart_contracts.zaibatsu_auth_and_dao.contract.ZaibatsuAuthAndDao.hello(name: bytes) -> bytes:
hello:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:15-16
    // @a4.abimethod()
    // def hello(self, name: a4.String) -> a4.String:
    proto 1 1
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:17
    // return "Hello, " + name
    frame_dig -1
    extract 2 0
    byte 0x48656c6c6f2c20
    swap
    concat
    dup
    len
    itob
    extract 6 2
    swap
    concat
    retsub


// smart_contracts.zaibatsu_auth_and_dao.contract.ZaibatsuAuthAndDao.create() -> uint64:
create:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:19-20
    // @a4.abimethod(create="allow")
    // def create(self) -> bool:
    proto 0 1
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:21
    // self.admins.append(a4.Address(ap.Txn.sender))
    int 0
    // smart_contracts/zaibatsu_base/contract.py:13
    // self.admins: AddressArray = AddressArray()
    byte "admins"
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:21
    // self.admins.append(a4.Address(ap.Txn.sender))
    app_global_get_ex
    assert // check self.admins exists
    extract 2 0
    txn Sender
    concat
    dup
    len
    int 32
    /
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/zaibatsu_base/contract.py:13
    // self.admins: AddressArray = AddressArray()
    byte "admins"
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:21
    // self.admins.append(a4.Address(ap.Txn.sender))
    swap
    app_global_put
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:22
    // return True
    int 1
    retsub


// smart_contracts.zaibatsu_auth_and_dao.contract.ZaibatsuAuthAndDao.update() -> uint64:
update:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:24-25
    // @a4.abimethod(allow_actions=["UpdateApplication"])
    // def update(self) -> bool:
    proto 0 1
    byte ""
    dup
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:26
    // if ap.Txn.sender == op.Global.creator_address:
    txn Sender
    global CreatorAddress
    ==
    bz update_after_if_else@2
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:27
    // return True
    int 1
    frame_bury 0
    retsub

update_after_if_else@2:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:28
    // for index in ap.urange(self.admins.length):
    int 0
    // smart_contracts/zaibatsu_base/contract.py:13
    // self.admins: AddressArray = AddressArray()
    byte "admins"
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:28
    // for index in ap.urange(self.admins.length):
    app_global_get_ex
    assert // check self.admins exists
    int 0
    extract_uint16
    frame_bury 1
    int 0
    frame_bury 0

update_for_header@3:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:28
    // for index in ap.urange(self.admins.length):
    frame_dig 0
    frame_dig 1
    <
    bz update_after_for@9
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:29
    // if self.admins[index] == ap.Txn.sender:
    int 0
    // smart_contracts/zaibatsu_base/contract.py:13
    // self.admins: AddressArray = AddressArray()
    byte "admins"
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:29
    // if self.admins[index] == ap.Txn.sender:
    app_global_get_ex
    assert // check self.admins exists
    extract 2 0
    frame_dig 0
    int 32
    *
    int 32
    extract3 // on error: Index access is out of bounds
    txn Sender
    ==
    bz update_after_if_else@6
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:30
    // return True
    int 1
    frame_bury 0
    retsub

update_after_if_else@6:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:28
    // for index in ap.urange(self.admins.length):
    frame_dig 0
    int 1
    +
    frame_bury 0
    b update_for_header@3

update_after_for@9:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:31
    // return False
    int 0
    frame_bury 0
    retsub


// smart_contracts.zaibatsu_auth_and_dao.contract.ZaibatsuAuthAndDao.delete() -> uint64:
delete:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:33-34
    // @a4.abimethod(allow_actions=["DeleteApplication"])
    // def delete(self) -> bool:
    proto 0 1
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:35
    // if ap.Txn.sender == op.Global.creator_address:
    txn Sender
    global CreatorAddress
    ==
    bz delete_after_if_else@2
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:36
    // return True
    int 1
    retsub

delete_after_if_else@2:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:37
    // return False
    int 0
    retsub


// smart_contracts.zaibatsu_auth_and_dao.contract.ZaibatsuAuthAndDao.set_service_contract_address(address: bytes) -> uint64:
set_service_contract_address:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:39-40
    // @a4.abimethod()
    // def set_service_contract_address(self, address: a4.Address) -> bool:
    proto 1 1
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:41
    // self.authorise_txn()
    callsub authorise_txn
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:42
    // self.service_contract_address = address
    byte "service_contract_address"
    frame_dig -1
    app_global_put
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:43
    // return True
    int 1
    retsub


// smart_contracts.zaibatsu_base.contract.ZaibatsuBase.authorise_txn() -> void:
authorise_txn:
    // smart_contracts/zaibatsu_base/contract.py:54-55
    // @ap.subroutine
    // def authorise_txn(self) -> None:
    proto 0 0
    byte ""
    dup
    // smart_contracts/zaibatsu_base/contract.py:56
    // is_authorised = a4.Bool()
    byte 0x00
    // smart_contracts/zaibatsu_base/contract.py:57
    // if ap.Txn.sender == op.Global.creator_address:
    txn Sender
    global CreatorAddress
    ==
    bz authorise_txn_else_body@2
    // smart_contracts/zaibatsu_base/contract.py:58
    // is_authorised = a4.Bool(True)  # noqa: FBT003
    byte 0x80
    frame_bury 2
    b authorise_txn_after_if_else@10

authorise_txn_else_body@2:
    // smart_contracts/zaibatsu_base/contract.py:60
    // for index in ap.urange(self.admins.length):
    int 0
    // smart_contracts/zaibatsu_base/contract.py:13
    // self.admins: AddressArray = AddressArray()
    byte "admins"
    // smart_contracts/zaibatsu_base/contract.py:60
    // for index in ap.urange(self.admins.length):
    app_global_get_ex
    assert // check self.admins exists
    int 0
    extract_uint16
    frame_bury 1
    int 0
    frame_bury 0

authorise_txn_for_header@3:
    // smart_contracts/zaibatsu_base/contract.py:60
    // for index in ap.urange(self.admins.length):
    frame_dig 0
    frame_dig 1
    <
    bz authorise_txn_after_if_else@10
    // smart_contracts/zaibatsu_base/contract.py:61
    // if self.admins[index] == ap.Txn.sender:
    int 0
    // smart_contracts/zaibatsu_base/contract.py:13
    // self.admins: AddressArray = AddressArray()
    byte "admins"
    // smart_contracts/zaibatsu_base/contract.py:61
    // if self.admins[index] == ap.Txn.sender:
    app_global_get_ex
    assert // check self.admins exists
    extract 2 0
    frame_dig 0
    int 32
    *
    int 32
    extract3 // on error: Index access is out of bounds
    txn Sender
    ==
    bz authorise_txn_after_if_else@6
    // smart_contracts/zaibatsu_base/contract.py:62
    // is_authorised = a4.Bool(True)  # noqa: FBT003
    byte 0x80
    frame_bury 2

authorise_txn_after_if_else@6:
    // smart_contracts/zaibatsu_base/contract.py:60
    // for index in ap.urange(self.admins.length):
    frame_dig 0
    int 1
    +
    frame_bury 0
    b authorise_txn_for_header@3

authorise_txn_after_if_else@10:
    // smart_contracts/zaibatsu_base/contract.py:63
    // assert is_authorised, "You are not authorised to perform this action"
    frame_dig 2
    byte 0x00
    !=
    assert // You are not authorised to perform this action
    retsub


// smart_contracts.zaibatsu_auth_and_dao.contract.ZaibatsuAuthAndDao.authorize_pool_creation(txn: uint64, folks_feed_oracle: uint64, pool_key: bytes, image_url: bytes, token_unit_name: bytes, token_asset_name: bytes, max_contributors: uint64, asset_decimals_multiplier: uint64) -> bytes:
authorize_pool_creation:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:45-56
    // @a4.abimethod()
    // def authorize_pool_creation(
    //     self,
    //     txn: gtxn.AssetTransferTransaction,
    //     folks_feed_oracle: ap.Application,
    //     pool_key: ap.String,
    //     image_url: ap.String,
    //     token_unit_name: ap.String,
    //     token_asset_name: ap.String,
    //     max_contributors: ap.UInt64,
    //     asset_decimals_multiplier: ap.UInt64,
    // ) -> PoolInfo:
    proto 8 1
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:58
    // txn.asset_receiver == self.service_contract_address.native
    frame_dig -8
    gtxns AssetReceiver
    int 0
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:42
    // self.service_contract_address = address
    byte "service_contract_address"
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:58
    // txn.asset_receiver == self.service_contract_address.native
    app_global_get_ex
    assert // check self.service_contract_address exists
    ==
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:57-59
    // assert (
    //     txn.asset_receiver == self.service_contract_address.native
    // ), "The asset_receiver mut be the ZaibatsuLoan account"
    assert // The asset_receiver mut be the ZaibatsuLoan account
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:61
    // asset_dollar_price = self.get_asset_price(folks_feed_oracle, txn.xfer_asset)
    frame_dig -8
    gtxns XferAsset
    frame_dig -7
    swap
    callsub get_asset_price
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:64
    // asset_dollar_price * txn.asset_amount
    frame_dig -8
    gtxns AssetAmount
    *
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:63-65
    // creation_fee = (
    //     asset_dollar_price * txn.asset_amount
    // ) // asset_decimals_multiplier
    frame_dig -1
    /
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:67-69
    // assert creation_fee >= ap.UInt64(
    //     20
    // ), "The asset_amount must be worth at least 20 dollars"
    int 20
    >=
    assert // The asset_amount must be worth at least 20 dollars
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:71
    // total = ap.UInt64(1000000) * max_contributors
    int 1000000
    frame_dig -2
    *
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:73
    // existing = op.Box.get(pool_key.bytes)
    frame_dig -6
    box_get
    bury 1
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:74
    // assert not existing[1], "A pool with this key already exists"
    !
    assert // A pool with this key already exists
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:82
    // manager=ap.Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:83-85
    // reserve=ap.Global.current_application_address,
    // freeze=ap.Global.current_application_address,
    // clawback=ap.Global.current_application_address,
    dupn 3
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:87
    // asset_txn.submit()
    itxn_begin
    itxn_field ConfigAssetClawback
    itxn_field ConfigAssetFreeze
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    frame_dig -3
    itxn_field ConfigAssetName
    frame_dig -4
    itxn_field ConfigAssetUnitName
    frame_dig -5
    itxn_field ConfigAssetURL
    dup
    itxn_field ConfigAssetTotal
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:76
    // asset_txn = ap.itxn.AssetConfig(
    int acfg
    itxn_field TypeEnum
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:77
    // fee=1000,
    int 1000
    itxn_field Fee
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:87
    // asset_txn.submit()
    itxn_submit
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:89
    // pool_key=a4.String(pool_key),
    frame_dig -6
    len
    itob
    extract 6 2
    frame_dig -6
    concat
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:90
    // token_balance=a4.UInt64(total),
    swap
    itob
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:91
    // pool_asset_id=a4.UInt64(op.ITxn.created_asset_id().id),
    itxn CreatedAssetID
    itob
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:88-92
    // pool_info = PoolInfo(
    //     pool_key=a4.String(pool_key),
    //     token_balance=a4.UInt64(total),
    //     pool_asset_id=a4.UInt64(op.ITxn.created_asset_id().id),
    // )
    byte 0x0012
    uncover 2
    concat
    swap
    concat
    swap
    concat
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:94
    // op.Box.put(pool_key.bytes, pool_info.bytes)
    frame_dig -6
    dig 1
    box_put
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:95
    // return pool_info
    retsub


// smart_contracts.zaibatsu_base.contract.ZaibatsuBase.get_asset_price(folks_feed_oracle: uint64, asa: uint64) -> uint64:
get_asset_price:
    // smart_contracts/zaibatsu_base/contract.py:106-109
    // @ap.subroutine
    // def get_asset_price(
    //     self, folks_feed_oracle: ap.Application, asa: ap.Asset
    // ) -> ap.UInt64:
    proto 2 1
    // smart_contracts/zaibatsu_base/contract.py:110
    // [value, exists] = op.AppGlobal.get_ex_bytes(folks_feed_oracle, op.itob(asa.id))
    frame_dig -1
    itob
    frame_dig -2
    swap
    app_global_get_ex
    // smart_contracts/zaibatsu_base/contract.py:111
    // assert exists, "This aset is not supported"
    assert // This aset is not supported
    // smart_contracts/zaibatsu_base/contract.py:112
    // return op.extract_uint64(value, ap.UInt64(0))
    int 0
    extract_uint64
    retsub


// smart_contracts.zaibatsu_auth_and_dao.contract.ZaibatsuAuthAndDao.optin_pool_asset(optin_txn: uint64, pool_key: bytes) -> void:
optin_pool_asset:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:97-102
    // @a4.abimethod()
    // def optin_pool_asset(
    //     self,
    //     optin_txn: gtxn.AssetTransferTransaction,
    //     pool_key: ap.String,
    // ) -> None:
    proto 2 0
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:103
    // pool_data, exists = op.Box.get(pool_key.bytes)
    frame_dig -1
    box_get
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:104
    // assert exists, "A pool with that key does not exist"
    assert // A pool with that key does not exist
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:108
    // optin_txn.xfer_asset.id == pool_info.pool_asset_id.native
    frame_dig -2
    gtxns XferAsset
    swap
    extract 10 8 // on error: Index access is out of bounds
    btoi
    ==
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:107-109
    // assert (
    //     optin_txn.xfer_asset.id == pool_info.pool_asset_id.native
    // ), "The OptIn txn asset must be the same as the pool asset"
    assert // The OptIn txn asset must be the same as the pool asset
    retsub


// smart_contracts.zaibatsu_auth_and_dao.contract.ZaibatsuAuthAndDao.fund_pool(pool_key: bytes, fund_amount: uint64, user_account: bytes, folks_feed_oracle: uint64, txn: uint64, pool_asset: uint64, asset_decimals_multiplier: uint64) -> bytes:
fund_pool:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:111-121
    // @a4.abimethod()
    // def fund_pool(
    //     self,
    //     pool_key: ap.String,
    //     fund_amount: ap.UInt64,
    //     user_account: ap.Account,
    //     folks_feed_oracle: ap.Application,
    //     txn: gtxn.AssetTransferTransaction,
    //     pool_asset: ap.Asset,
    //     asset_decimals_multiplier: ap.UInt64,
    // ) -> PoolFundResponse:
    proto 7 1
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:122
    // pool_data, exists = op.Box.get(pool_key.bytes)
    frame_dig -7
    box_get
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:123
    // assert exists, "A pool with that key does not exist"
    assert // A pool with that key does not exist
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:127
    // user_account == txn.sender
    frame_dig -3
    gtxns Sender
    frame_dig -5
    ==
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:126-128
    // assert (
    //     user_account == txn.sender
    // ), "The user account must be the same as the txn sender"
    assert // The user account must be the same as the txn sender
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:130
    // pool_asset.id == pool_info.pool_asset_id.native
    dup
    extract 10 8 // on error: Index access is out of bounds
    btoi
    frame_dig -2
    dig 1
    ==
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:129-131
    // assert (
    //     pool_asset.id == pool_info.pool_asset_id.native
    // ), "pool_asset must match the asset of the specified pool"
    assert // pool_asset must match the asset of the specified pool
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:133
    // asset_dollar_price = self.get_asset_price(folks_feed_oracle, txn.xfer_asset)
    frame_dig -3
    gtxns XferAsset
    frame_dig -4
    swap
    callsub get_asset_price
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:134
    // asset_amount = txn.asset_amount
    frame_dig -3
    gtxns AssetAmount
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:137
    // asset_amount // asset_decimals_multiplier * asset_dollar_price
    dup
    frame_dig -1
    /
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:136-138
    // asset_value_in_usd = (
    //     asset_amount // asset_decimals_multiplier * asset_dollar_price
    // )
    uncover 2
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:137
    // asset_amount // asset_decimals_multiplier * asset_dollar_price
    *
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:147
    // reward_txn.submit()
    itxn_begin
    uncover 2
    itxn_field XferAsset
    dup
    itxn_field AssetAmount
    frame_dig -5
    itxn_field AssetReceiver
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:142
    // note="Pool fund reward",
    byte "Pool fund reward"
    itxn_field Note
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:140
    // reward_txn = ap.itxn.AssetTransfer(
    int axfer
    itxn_field TypeEnum
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:141
    // fee=1000,
    int 1000
    itxn_field Fee
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:147
    // reward_txn.submit()
    itxn_submit
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:149
    // pool_info.token_balance = a4.UInt64(pool_info.token_balance.native - asset_value_in_usd)
    dig 2
    extract 2 8 // on error: Index access is out of bounds
    btoi
    swap
    -
    itob
    uncover 2
    swap
    replace2 2
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:152
    // txn.asset_receiver == self.service_contract_address.native
    frame_dig -3
    gtxns AssetReceiver
    int 0
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:42
    // self.service_contract_address = address
    byte "service_contract_address"
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:152
    // txn.asset_receiver == self.service_contract_address.native
    app_global_get_ex
    assert // check self.service_contract_address exists
    ==
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:151-153
    // assert (
    //     txn.asset_receiver == self.service_contract_address.native
    // ), "The asset_receiver mut be the ZaibatsuService account"
    assert // The asset_receiver mut be the ZaibatsuService account
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:155-157
    // amount_plus_transaction_fee = self.calculate_amt_plus_fee(
    //     fund_amount, ap.UInt64(1)
    // )
    frame_dig -6
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:156
    // fund_amount, ap.UInt64(1)
    int 1
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:155-157
    // amount_plus_transaction_fee = self.calculate_amt_plus_fee(
    //     fund_amount, ap.UInt64(1)
    // )
    callsub calculate_amt_plus_fee
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:159
    // txn.asset_amount >= amount_plus_transaction_fee
    uncover 2
    <=
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:158-160
    // assert (
    //     txn.asset_amount >= amount_plus_transaction_fee
    // ), "The txn amount is insufficient"
    assert // The txn amount is insufficient
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:163
    // amount=a4.UInt64(fund_amount),
    frame_dig -6
    itob
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:164
    // success=a4.Bool(True),  # noqa: FBT003
    byte 0x80
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:162-165
    // response = PoolFundResponse(
    //     amount=a4.UInt64(fund_amount),
    //     success=a4.Bool(True),  # noqa: FBT003
    // )
    concat
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:166
    // op.Box.put(pool_key.bytes, pool_info.bytes)
    frame_dig -7
    uncover 2
    box_put
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:167
    // return response
    retsub


// smart_contracts.zaibatsu_base.contract.ZaibatsuBase.calculate_amt_plus_fee(amt: uint64, multiples: uint64) -> uint64:
calculate_amt_plus_fee:
    // smart_contracts/zaibatsu_base/contract.py:99-100
    // @ap.subroutine
    // def calculate_amt_plus_fee(self, amt: ap.UInt64, multiples: ap.UInt64) -> ap.UInt64:
    proto 2 1
    // smart_contracts/zaibatsu_base/contract.py:101
    // fee_percentage = ap.UInt64(5) * multiples
    int 5
    frame_dig -1
    *
    // smart_contracts/zaibatsu_base/contract.py:102
    // multiplied = fee_percentage * amt
    frame_dig -2
    *
    // smart_contracts/zaibatsu_base/contract.py:103
    // half_percent = multiplied // 1000
    int 1000
    /
    // smart_contracts/zaibatsu_base/contract.py:104
    // return half_percent
    retsub


// smart_contracts.zaibatsu_auth_and_dao.contract.ZaibatsuAuthAndDao.approve_pool_vote(pool_key: bytes, txn: uint64) -> bytes:
approve_pool_vote:
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:169-174
    // @a4.abimethod()
    // def approve_pool_vote(
    //     self,
    //     pool_key: ap.String,
    //     txn: gtxn.AssetTransferTransaction,
    // ) -> PoolVoteApprovalResponse:
    proto 2 1
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:175
    // box_data, exists = op.Box.get(pool_key.bytes)
    frame_dig -2
    box_get
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:176
    // assert exists, "PoolInfo with that key does not exist"
    assert // PoolInfo with that key does not exist
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:179
    // txn.xfer_asset.id == pool_info.pool_asset_id.native
    frame_dig -1
    gtxns XferAsset
    swap
    extract 10 8 // on error: Index access is out of bounds
    btoi
    ==
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:178-180
    // assert (
    //     txn.xfer_asset.id == pool_info.pool_asset_id.native
    // ), "The asset transfered must be the pool token"
    assert // The asset transfered must be the pool token
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:183
    // multiplier=a4.UInt64(txn.asset_amount),
    frame_dig -1
    gtxns AssetAmount
    itob
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:184
    // txn_id=a4.String.from_bytes(txn.txn_id),
    frame_dig -1
    gtxns TxID
    swap
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:182-185
    // response = PoolVoteApprovalResponse(
    //     multiplier=a4.UInt64(txn.asset_amount),
    //     txn_id=a4.String.from_bytes(txn.txn_id),
    // )
    byte 0x000a
    concat
    swap
    concat
    // smart_contracts/zaibatsu_auth_and_dao/contract.py:186
    // return response
    retsub


// smart_contracts.zaibatsu_base.contract.ZaibatsuBase.opt_contract_into_asset(asset: uint64) -> uint64:
opt_contract_into_asset:
    // smart_contracts/zaibatsu_base/contract.py:36-37
    // @a4.abimethod()
    // def opt_contract_into_asset(self, asset: ap.Asset) -> bool:
    proto 1 1
    // smart_contracts/zaibatsu_base/contract.py:38
    // self.opt_app_into_asset(asset)
    frame_dig -1
    callsub opt_app_into_asset
    // smart_contracts/zaibatsu_base/contract.py:39
    // return True
    int 1
    retsub


// smart_contracts.zaibatsu_base.contract.ZaibatsuBase.opt_app_into_asset(asset: uint64) -> void:
opt_app_into_asset:
    // smart_contracts/zaibatsu_base/contract.py:41-45
    // ################################################################
    // #####################   Subroutines    #########################
    // ################################################################
    // @ap.subroutine
    // def opt_app_into_asset(self, asset: ap.Asset) -> None:
    proto 1 0
    // smart_contracts/zaibatsu_base/contract.py:50
    // asset_receiver=ap.Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/zaibatsu_base/contract.py:52
    // txn.submit()
    itxn_begin
    itxn_field AssetReceiver
    frame_dig -1
    itxn_field XferAsset
    // smart_contracts/zaibatsu_base/contract.py:47
    // asset_amount=0,
    int 0
    itxn_field AssetAmount
    // smart_contracts/zaibatsu_base/contract.py:46
    // txn = ap.itxn.AssetTransfer(
    int axfer
    itxn_field TypeEnum
    // smart_contracts/zaibatsu_base/contract.py:48
    // fee=1000,
    int 1000
    itxn_field Fee
    // smart_contracts/zaibatsu_base/contract.py:52
    // txn.submit()
    itxn_submit
    retsub


// smart_contracts.zaibatsu_base.contract.ZaibatsuBase.__init__() -> void:
__init__:
    // smart_contracts/zaibatsu_base/contract.py:12
    // def __init__(self) -> None:
    proto 0 0
    // smart_contracts/zaibatsu_base/contract.py:13
    // self.admins: AddressArray = AddressArray()
    byte "admins"
    byte 0x0000
    app_global_put
    // smart_contracts/zaibatsu_base/contract.py:14
    // self.service_contract: a4.Address = a4.Address()
    byte "service_contract"
    global ZeroAddress
    app_global_put
    retsub
