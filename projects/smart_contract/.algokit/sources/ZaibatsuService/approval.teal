#pragma version 10

smart_contracts.zaibatsu_service.contract.ZaibatsuService.approval_program:
    txn ApplicationID
    bnz main_entrypoint@2
    callsub __init__

main_entrypoint@2:
    // smart_contracts/zaibatsu_service/contract.py:13
    // class ZaibatsuService(ap.ARC4Contract):
    method "hello(string)string"
    method "create()bool"
    method "update()bool"
    method "delete()bool"
    method "iniate_p2p_loan_purchase(byte[],application,(string,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint64,(uint64,address)[],string,bool,bool,uint8,address,uint64,uint64),axfer)(string,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint64,(uint64,address)[],string,bool,bool,uint8,address,uint64,uint64)"
    method "complete_p2p_loan_purchase((string,string,string,string,string),axfer)(string,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint8,uint64,(uint64,address)[],string,bool,bool,uint8,address,uint64,uint64)"
    txna ApplicationArgs 0
    match main_hello_route@3 main_create_route@4 main_update_route@5 main_delete_route@6 main_iniate_p2p_loan_purchase_route@7 main_complete_p2p_loan_purchase_route@8
    err // reject transaction

main_hello_route@3:
    // smart_contracts/zaibatsu_service/contract.py:23
    // @ap.arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // smart_contracts/zaibatsu_service/contract.py:13
    // class ZaibatsuService(ap.ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/zaibatsu_service/contract.py:23
    // @ap.arc4.abimethod()
    callsub hello
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_create_route@4:
    // smart_contracts/zaibatsu_service/contract.py:27
    // @a4.abimethod(create="allow")
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    callsub create
    byte 0x00
    int 0
    uncover 2
    setbit
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_update_route@5:
    // smart_contracts/zaibatsu_service/contract.py:32
    // @a4.abimethod(allow_actions=["UpdateApplication"])
    txn OnCompletion
    int UpdateApplication
    ==
    assert // OnCompletion is UpdateApplication
    txn ApplicationID
    assert // is not creating
    callsub update
    byte 0x00
    int 0
    uncover 2
    setbit
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_delete_route@6:
    // smart_contracts/zaibatsu_service/contract.py:41
    // @a4.abimethod(allow_actions=["DeleteApplication"])
    txn OnCompletion
    int DeleteApplication
    ==
    assert // OnCompletion is DeleteApplication
    txn ApplicationID
    assert // is not creating
    callsub delete
    byte 0x00
    int 0
    uncover 2
    setbit
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_iniate_p2p_loan_purchase_route@7:
    // smart_contracts/zaibatsu_service/contract.py:47
    // @a4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // smart_contracts/zaibatsu_service/contract.py:13
    // class ZaibatsuService(ap.ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txnas Applications
    txna ApplicationArgs 3
    txn GroupIndex
    int 1
    -
    dup
    gtxns TypeEnum
    int axfer
    ==
    assert // transaction type is axfer
    // smart_contracts/zaibatsu_service/contract.py:47
    // @a4.abimethod()
    callsub iniate_p2p_loan_purchase
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_complete_p2p_loan_purchase_route@8:
    // smart_contracts/zaibatsu_service/contract.py:88
    // @ap.arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // smart_contracts/zaibatsu_service/contract.py:13
    // class ZaibatsuService(ap.ARC4Contract):
    txna ApplicationArgs 1
    txn GroupIndex
    int 1
    -
    dup
    gtxns TypeEnum
    int axfer
    ==
    assert // transaction type is axfer
    // smart_contracts/zaibatsu_service/contract.py:88
    // @ap.arc4.abimethod()
    callsub complete_p2p_loan_purchase
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return


// smart_contracts.zaibatsu_service.contract.ZaibatsuService.hello(name: bytes) -> bytes:
hello:
    // smart_contracts/zaibatsu_service/contract.py:23-24
    // @ap.arc4.abimethod()
    // def hello(self, name: a4.String) -> ap.arc4.String:
    proto 1 1
    // smart_contracts/zaibatsu_service/contract.py:25
    // return "Hello, " + name
    frame_dig -1
    extract 2 0
    byte "Hello, "
    swap
    concat
    dup
    len
    itob
    extract 6 0
    swap
    concat
    retsub


// smart_contracts.zaibatsu_service.contract.ZaibatsuService.create() -> uint64:
create:
    // smart_contracts/zaibatsu_service/contract.py:27-28
    // @a4.abimethod(create="allow")
    // def create(self) -> bool:
    proto 0 1
    // smart_contracts/zaibatsu_service/contract.py:29
    // self.admins.append(a4.Address(ap.Txn.sender))
    int 0
    byte "admins"
    app_global_get_ex
    assert // check admins exists
    extract 2 0
    txn Sender
    concat
    dup
    len
    int 32
    /
    itob
    extract 6 0
    swap
    concat
    byte "admins"
    swap
    app_global_put
    // smart_contracts/zaibatsu_service/contract.py:30
    // return True
    int 1
    retsub


// smart_contracts.zaibatsu_service.contract.ZaibatsuService.update() -> uint64:
update:
    // smart_contracts/zaibatsu_service/contract.py:32-33
    // @a4.abimethod(allow_actions=["UpdateApplication"])
    // def update(self) -> bool:
    proto 0 1
    byte ""
    dup
    // smart_contracts/zaibatsu_service/contract.py:34
    // if ap.Txn.sender == op.Global.creator_address:
    txn Sender
    global CreatorAddress
    ==
    bz update_after_if_else@2
    // smart_contracts/zaibatsu_service/contract.py:35
    // return True
    int 1
    frame_bury 0
    retsub

update_after_if_else@2:
    // smart_contracts/zaibatsu_service/contract.py:36
    // for index in ap.urange(self.admins.length):
    int 0
    byte "admins"
    app_global_get_ex
    assert // check admins exists
    int 0
    extract_uint16
    frame_bury 1
    int 0
    frame_bury 0

update_for_header@3:
    // smart_contracts/zaibatsu_service/contract.py:36
    // for index in ap.urange(self.admins.length):
    frame_dig 0
    frame_dig 1
    <
    bz update_after_for@9
    // smart_contracts/zaibatsu_service/contract.py:37
    // if self.admins[index] == ap.Txn.sender:
    int 0
    byte "admins"
    app_global_get_ex
    assert // check admins exists
    dup
    int 0
    extract_uint16
    frame_dig 0
    dup
    uncover 2
    <
    assert // Index access is out of bounds
    swap
    extract 2 0
    swap
    int 32
    *
    int 32
    extract3
    txn Sender
    ==
    bz update_after_if_else@6
    // smart_contracts/zaibatsu_service/contract.py:38
    // return True
    int 1
    frame_bury 0
    retsub

update_after_if_else@6:
    // smart_contracts/zaibatsu_service/contract.py:36
    // for index in ap.urange(self.admins.length):
    frame_dig 0
    int 1
    +
    frame_bury 0
    b update_for_header@3

update_after_for@9:
    // smart_contracts/zaibatsu_service/contract.py:39
    // return False
    int 0
    frame_bury 0
    retsub


// smart_contracts.zaibatsu_service.contract.ZaibatsuService.delete() -> uint64:
delete:
    // smart_contracts/zaibatsu_service/contract.py:41-42
    // @a4.abimethod(allow_actions=["DeleteApplication"])
    // def delete(self) -> bool:
    proto 0 1
    // smart_contracts/zaibatsu_service/contract.py:43
    // if ap.Txn.sender == op.Global.creator_address:
    txn Sender
    global CreatorAddress
    ==
    bz delete_after_if_else@2
    // smart_contracts/zaibatsu_service/contract.py:44
    // return True
    int 1
    retsub

delete_after_if_else@2:
    // smart_contracts/zaibatsu_service/contract.py:45
    // return False
    int 0
    retsub


// smart_contracts.zaibatsu_service.contract.ZaibatsuService.iniate_p2p_loan_purchase(loan_key: bytes, folks_feed_oracle: uint64, loan_details: bytes, txn: uint64) -> bytes:
iniate_p2p_loan_purchase:
    // smart_contracts/zaibatsu_service/contract.py:47-54
    // @a4.abimethod()
    // def iniate_p2p_loan_purchase(
    //     self,
    //     loan_key: ap.Bytes,
    //     folks_feed_oracle: ap.Application,
    //     loan_details: LoanDetails,
    //     txn: gtxn.AssetTransferTransaction,
    // ) -> LoanDetails:
    proto 4 1
    // smart_contracts/zaibatsu_service/contract.py:56
    // txn.asset_receiver == Global.current_application_address
    frame_dig -1
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/zaibatsu_service/contract.py:55-57
    // assert (
    //     txn.asset_receiver == Global.current_application_address
    // ), "The recipient must be the ZaibatsuService address"
    assert // The recipient must be the ZaibatsuService address
    // smart_contracts/zaibatsu_service/contract.py:59
    // val = op.Box.get(loan_key)
    frame_dig -4
    box_get
    bury 1
    // smart_contracts/zaibatsu_service/contract.py:60
    // assert not val[1], "A Loan purchase with this key has already been initiated"
    !
    assert // A Loan purchase with this key has already been initiated
    // smart_contracts/zaibatsu_service/contract.py:62
    // collateral_price = self.get_asset_price(folks_feed_oracle, txn.xfer_asset)
    frame_dig -1
    gtxns XferAsset
    frame_dig -3
    dig 1
    callsub get_asset_price
    // smart_contracts/zaibatsu_service/contract.py:63
    // assert collateral_price > 0, "The asa is of no value or is not supported"
    assert // The asa is of no value or is not supported
    // smart_contracts/zaibatsu_service/contract.py:65
    // assert loan_details.loan_type == a4.String("P2P"), "The loan must be a P2P loan"
    frame_dig -2
    int 0
    extract_uint16
    frame_dig -2
    dig 1
    extract_uint16
    int 2
    +
    frame_dig -2
    cover 2
    extract3
    byte "\x00\x03P2P"
    ==
    assert // The loan must be a P2P loan
    // smart_contracts/zaibatsu_service/contract.py:66
    // assert not loan_details.collateral_paid, "The loan collateral must not be paid"
    frame_dig -2
    int 512
    getbit
    byte 0x00
    int 0
    uncover 2
    setbit
    byte 0x00
    ==
    assert // The loan collateral must not be paid
    // smart_contracts/zaibatsu_service/contract.py:67
    // assert not loan_details.principal_paid, "The loan principal must not be paid"
    frame_dig -2
    int 513
    getbit
    byte 0x00
    int 0
    uncover 2
    setbit
    byte 0x00
    ==
    assert // The loan principal must not be paid
    // smart_contracts/zaibatsu_service/contract.py:68
    // assert loan_details.payment_recipients.length == ap.UInt64(1), "Only one recipient is allowed in a P2P loan"
    frame_dig -2
    int 60
    extract_uint16
    frame_dig -2
    dig 1
    extract_uint16
    int 2
    +
    frame_dig -2
    cover 2
    extract3
    int 0
    extract_uint16
    int 1
    ==
    assert // Only one recipient is allowed in a P2P loan
    // smart_contracts/zaibatsu_service/contract.py:69
    // assert loan_details.borrower == txn.sender, "The sender must also be the borrower"
    frame_dig -2
    extract 66 32
    frame_dig -1
    gtxns Sender
    ==
    assert // The sender must also be the borrower
    // smart_contracts/zaibatsu_service/contract.py:72
    // loan_details.collateral_asset_id == txn.xfer_asset.id
    frame_dig -2
    extract 11 8
    dig 1
    itob
    b==
    // smart_contracts/zaibatsu_service/contract.py:71-73
    // assert (
    //     loan_details.collateral_asset_id == txn.xfer_asset.id
    // ), "The asset being transfered must be the collateral asset"
    assert // The asset being transfered must be the collateral asset
    // smart_contracts/zaibatsu_service/contract.py:75
    // op.btoi(loan_details.collateral_asset_amount.bytes) == txn.asset_amount
    frame_dig -2
    extract 35 8
    btoi
    frame_dig -1
    gtxns AssetAmount
    ==
    // smart_contracts/zaibatsu_service/contract.py:74-76
    // assert (
    //     op.btoi(loan_details.collateral_asset_amount.bytes) == txn.asset_amount
    // ), "The amount of asset transfered must equal the amount specified"
    assert // The amount of asset transfered must equal the amount specified
    // smart_contracts/zaibatsu_service/contract.py:78
    // op.btoi(loan_details.payment_completion_timestamp.bytes) > op.Global.latest_timestamp
    frame_dig -2
    extract 52 8
    btoi
    global LatestTimestamp
    >
    // smart_contracts/zaibatsu_service/contract.py:77-79
    // assert (
    //     op.btoi(loan_details.payment_completion_timestamp.bytes) > op.Global.latest_timestamp
    // ), "The payment completion timestamp must be greater than now"
    assert // The payment completion timestamp must be greater than now
    // smart_contracts/zaibatsu_service/contract.py:80
    // self._opt_contract_into_asset(txn.xfer_asset)
    callsub _opt_contract_into_asset
    pop
    // smart_contracts/zaibatsu_service/contract.py:82
    // loan_details.collateral_paid = a4.Bool(True)  # noqa: FBT003
    frame_dig -2
    int 512
    int 1
    setbit
    frame_bury -2
    // smart_contracts/zaibatsu_service/contract.py:84
    // op.Box.put(loan_key, loan_details.bytes)
    frame_dig -4
    frame_dig -2
    box_put
    // smart_contracts/zaibatsu_service/contract.py:86
    // return loan_details
    frame_dig -2
    retsub


// smart_contracts.zaibatsu_service.contract.ZaibatsuService.get_asset_price(folks_feed_oracle: uint64, asa: uint64) -> uint64:
get_asset_price:
    // smart_contracts/zaibatsu_service/contract.py:140-141
    // @ap.subroutine
    // def get_asset_price(self, folks_feed_oracle: ap.Application, asa: ap.Asset) -> ap.UInt64:
    proto 2 1
    // smart_contracts/zaibatsu_service/contract.py:142
    // [value, exists] = op.AppGlobal.get_ex_bytes(folks_feed_oracle, op.itob(asa.id))
    frame_dig -1
    itob
    frame_dig -2
    swap
    app_global_get_ex
    // smart_contracts/zaibatsu_service/contract.py:143
    // assert exists, "This aset is not supported"
    assert // This aset is not supported
    // smart_contracts/zaibatsu_service/contract.py:144
    // return op.extract_uint64(value, ap.UInt64(0))
    int 0
    extract_uint64
    retsub


// smart_contracts.zaibatsu_service.contract.ZaibatsuService._opt_contract_into_asset(asset_id: uint64) -> uint64:
_opt_contract_into_asset:
    // smart_contracts/zaibatsu_service/contract.py:161-162
    // @ap.subroutine
    // def _opt_contract_into_asset(self, asset_id: ap.Asset) -> bool:
    proto 1 1
    // smart_contracts/zaibatsu_service/contract.py:166
    // asset_receiver=ap.Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/zaibatsu_service/contract.py:168
    // txn.submit()
    itxn_begin
    itxn_field AssetReceiver
    frame_dig -1
    itxn_field XferAsset
    // smart_contracts/zaibatsu_service/contract.py:163
    // txn = ap.itxn.AssetTransfer(
    int axfer
    itxn_field TypeEnum
    // smart_contracts/zaibatsu_service/contract.py:165
    // fee=1000,
    int 1000
    itxn_field Fee
    // smart_contracts/zaibatsu_service/contract.py:168
    // txn.submit()
    itxn_submit
    // smart_contracts/zaibatsu_service/contract.py:169
    // return True
    int 1
    retsub


// smart_contracts.zaibatsu_service.contract.ZaibatsuService.complete_p2p_loan_purchase(completion_args: bytes, txn: uint64) -> bytes:
complete_p2p_loan_purchase:
    // smart_contracts/zaibatsu_service/contract.py:88-91
    // @ap.arc4.abimethod()
    // def complete_p2p_loan_purchase(
    //     self, completion_args: CompleteLoanArgs, txn: gtxn.AssetTransferTransaction
    // ) -> LoanDetails:
    proto 2 1
    // smart_contracts/zaibatsu_service/contract.py:92
    // [loan_bytes, exists] = op.Box.get(completion_args.loan_key.bytes)
    frame_dig -2
    int 0
    extract_uint16
    frame_dig -2
    dig 1
    extract_uint16
    int 2
    +
    frame_dig -2
    cover 2
    extract3
    dup
    box_get
    // smart_contracts/zaibatsu_service/contract.py:93
    // assert exists, "A reccord with the loan_key passed was not found"
    assert // A reccord with the loan_key passed was not found
    // smart_contracts/zaibatsu_service/contract.py:95
    // assert details.collateral_paid, "The loan collateral must have been paid by this point"
    dup
    int 512
    getbit
    byte 0x00
    int 0
    uncover 2
    setbit
    byte 0x00
    !=
    assert // The loan collateral must have been paid by this point
    // smart_contracts/zaibatsu_service/contract.py:96
    // assert not details.principal_paid, "The principal must not have been paid"
    dup
    int 513
    getbit
    byte 0x00
    int 0
    uncover 2
    setbit
    byte 0x00
    ==
    assert // The principal must not have been paid
    // smart_contracts/zaibatsu_service/contract.py:97
    // assert txn.asset_receiver == details.borrower, "The borrower must be the reciever"
    dup
    extract 66 32
    frame_dig -1
    gtxns AssetReceiver
    ==
    assert // The borrower must be the reciever
    // smart_contracts/zaibatsu_service/contract.py:98
    // assert txn.xfer_asset.id == details.principal_asset_id, "The asset transfered must be the same as the principal"
    dup
    extract 3 8
    frame_dig -1
    gtxns XferAsset
    itob
    b==
    assert // The asset transfered must be the same as the principal
    // smart_contracts/zaibatsu_service/contract.py:101
    // txn.asset_amount == details.lend_asset_amount
    dup
    extract 27 8
    frame_dig -1
    gtxns AssetAmount
    itob
    b==
    // smart_contracts/zaibatsu_service/contract.py:100-102
    // assert (
    //     txn.asset_amount == details.lend_asset_amount
    // ), "The asset transfered must equal the lend_asset_amount recorded"
    assert // The asset transfered must equal the lend_asset_amount recorded
    // smart_contracts/zaibatsu_service/contract.py:103
    // details.principal_paid = a4.Bool(True)  # noqa: FBT003
    int 513
    int 1
    setbit
    // smart_contracts/zaibatsu_service/contract.py:104
    // details.completed_payment_rounds = a4.UInt8(0)
    byte 0x00
    replace2 65
    // smart_contracts/zaibatsu_service/contract.py:106
    // completion_args.borrower_nft_image_url,
    frame_dig -2
    int 6
    extract_uint16
    frame_dig -2
    dig 1
    extract_uint16
    int 2
    +
    frame_dig -2
    cover 2
    extract3
    // smart_contracts/zaibatsu_service/contract.py:107
    // op.concat(ap.Bytes(b"B"), completion_args.loan_number.native.bytes),
    frame_dig -2
    int 2
    extract_uint16
    frame_dig -2
    dig 1
    extract_uint16
    int 2
    +
    frame_dig -2
    cover 2
    extract3
    extract 2 0
    byte "B"
    dig 1
    concat
    swap
    // smart_contracts/zaibatsu_service/contract.py:108
    // op.concat(ap.Bytes(b"ZAI-L #B"), completion_args.loan_number.native.bytes),
    byte "ZAI-L #B"
    dig 1
    concat
    // smart_contracts/zaibatsu_service/contract.py:109
    // completion_args.loan_hash,
    frame_dig -2
    int 8
    extract_uint16
    frame_dig -2
    dig 1
    extract_uint16
    int 2
    +
    frame_dig -2
    cover 2
    extract3
    // smart_contracts/zaibatsu_service/contract.py:105-110
    // borrower_nft = self.create_loan_nft(
    //     completion_args.borrower_nft_image_url,
    //     op.concat(ap.Bytes(b"B"), completion_args.loan_number.native.bytes),
    //     op.concat(ap.Bytes(b"ZAI-L #B"), completion_args.loan_number.native.bytes),
    //     completion_args.loan_hash,
    // )
    uncover 4
    uncover 4
    uncover 3
    dig 3
    callsub create_loan_nft
    swap
    // smart_contracts/zaibatsu_service/contract.py:112
    // completion_args.lender_nft_image_url,
    frame_dig -2
    int 4
    extract_uint16
    frame_dig -2
    dig 1
    extract_uint16
    int 2
    +
    frame_dig -2
    cover 2
    extract3
    // smart_contracts/zaibatsu_service/contract.py:113
    // op.concat(ap.Bytes(b"L"), completion_args.loan_number.native.bytes),
    byte "L"
    dig 4
    concat
    swap
    // smart_contracts/zaibatsu_service/contract.py:114
    // op.concat(ap.Bytes(b"ZAI-L #L"), completion_args.loan_number.native.bytes),
    byte "ZAI-L #L"
    uncover 5
    concat
    // smart_contracts/zaibatsu_service/contract.py:111-116
    // lender_nft = self.create_loan_nft(
    //     completion_args.lender_nft_image_url,
    //     op.concat(ap.Bytes(b"L"), completion_args.loan_number.native.bytes),
    //     op.concat(ap.Bytes(b"ZAI-L #L"), completion_args.loan_number.native.bytes),
    //     completion_args.loan_hash,
    // )
    swap
    uncover 2
    uncover 2
    uncover 3
    callsub create_loan_nft
    // smart_contracts/zaibatsu_service/contract.py:117
    // details.borrower_nft_asser_id = A4UInt64(borrower_nft.id)
    swap
    itob
    uncover 2
    swap
    replace2 106
    // smart_contracts/zaibatsu_service/contract.py:118
    // details.lender_nft_asser_id = A4UInt64(lender_nft.id)
    swap
    itob
    replace2 98
    // smart_contracts/zaibatsu_service/contract.py:119
    // op.Box.put(completion_args.loan_key.native.bytes, details.bytes)
    swap
    extract 2 0
    dig 1
    box_put
    // smart_contracts/zaibatsu_service/contract.py:120
    // return details
    retsub


// smart_contracts.zaibatsu_service.contract.ZaibatsuService.create_loan_nft(image_url: bytes, short_name: bytes, logn_name: bytes, loan_hash: bytes) -> uint64:
create_loan_nft:
    // smart_contracts/zaibatsu_service/contract.py:122-125
    // @ap.subroutine
    // def create_loan_nft(
    //     self, image_url: a4.String, short_name: ap.Bytes, logn_name: ap.Bytes, loan_hash: a4.String
    // ) -> ap.Asset:
    proto 4 1
    // smart_contracts/zaibatsu_service/contract.py:128
    // url=image_url.native,
    frame_dig -4
    extract 2 0
    // smart_contracts/zaibatsu_service/contract.py:131
    // metadata_hash=loan_hash.native.bytes,
    frame_dig -1
    extract 2 0
    // smart_contracts/zaibatsu_service/contract.py:132
    // manager=op.Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/zaibatsu_service/contract.py:133-135
    // reserve=op.Global.current_application_address,
    // freeze=op.Global.current_application_address,
    // clawback=op.Global.current_application_address,
    dupn 3
    // smart_contracts/zaibatsu_service/contract.py:137
    // txn.submit()
    itxn_begin
    itxn_field ConfigAssetClawback
    itxn_field ConfigAssetFreeze
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    itxn_field ConfigAssetMetadataHash
    frame_dig -2
    itxn_field ConfigAssetName
    frame_dig -3
    itxn_field ConfigAssetUnitName
    itxn_field ConfigAssetURL
    // smart_contracts/zaibatsu_service/contract.py:127
    // total=1,
    int 1
    itxn_field ConfigAssetTotal
    // smart_contracts/zaibatsu_service/contract.py:126
    // txn = ap.itxn.AssetConfig(
    int acfg
    itxn_field TypeEnum
    int 0
    itxn_field Fee
    // smart_contracts/zaibatsu_service/contract.py:137
    // txn.submit()
    itxn_submit
    // smart_contracts/zaibatsu_service/contract.py:138
    // return op.ITxn.created_asset_id()
    itxn CreatedAssetID
    retsub


// smart_contracts.zaibatsu_service.contract.ZaibatsuService.__init__() -> void:
__init__:
    // smart_contracts/zaibatsu_service/contract.py:20
    // def __init__(self) -> None:
    proto 0 0
    // smart_contracts/zaibatsu_service/contract.py:21
    // self.admins: AddressArray = AddressArray()
    byte "admins"
    byte 0x0000
    app_global_put
    retsub